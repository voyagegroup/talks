Go
Treasure2021版 Day2
Tags: golang

Jumpei Chikamori
Gopher at VOYAGE GROUP
@pei0804
https://github.com/pei0804

* この資料について

VOYAGE GROUPの学生エンジニア向けインターンシップTreasureの2021年度版講義資料です。Goの講義は2日間です。

GitHubで公開されています。

.link https://github.com/voyagegroup/talks
.link https://talks.godoc.org/github.com/voyagegroup/talks/2021/treasure-go/go.slide

* はじめに

* アイスブレイク 5分

- 好きな言語
- 好きなエディタ
- 最近つくってるもの

* Treasureについて簡単に

- バックグラウンドの違うみなさんが3週間過ごします
- どんどん話してください
- コードを書いて、質問して、がっつり勉強してください

Enjoy! :)

* 2日間で学んでほしいこと

- Goで小さなコマンドラインツールを書けるようになること
- 一通り小さなWebアプリケーションを書けるようになること
- Goのコードの書き方に慣れること

とにかくどんどんコードを書きましょう。

* 講義のゴール

一般的なWebアプリケーションに求められるスペックをGoで作れる。

.image https://golang.org/doc/gopher/project.png

* バックエンドの環境構築

README.md通りに進めると出来上がります。
.link https://github.com/VG-Tech-Dojo/treasure-app-2021

* ベースアプリの構成

.image ./assets/arch.png 540 717

* ベースアプリの構成

- cmd コマンド。
- app アプリケーションコード置き場。
- app/db データベース系。
- app/interfaces 利用者とのやり取り。
- app/usecase 利用者の目的を達成する部分。例えば、記事を投稿する。
- app/domain ビジネスロジック。
- app/domain/repository 永続化層とのやり取り。
- app/domain/model 永続層のモデル定義。

他にもいくつかあるけど、ここでは割愛します。

* 命名規則

Railsを参考にしました。
命名などで悩まず、今日はガンガン書いてほしい意図で採用しているだけなので、基本的には自由です。

.link https://railsguides.jp/routing.html ルーティング

.link https://railsguides.jp/active_record_basics.html アクティブレコード

* ステータスコードやルーティング規則の参考資料

.link https://developer.mozilla.org/ja/docs/Web/HTTP/Status MDN Web docs

.link https://www.oreilly.co.jp/books/9784873116860/ Web API: The Good Parts

.link https://developer.github.com/v3/ Github REST APIv3

.link https://qiita.com/mserizawa/items/b833e407d89abd21ee72#%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF%E3%82%BD%E3%83%BC%E3%83%88%E6%A4%9C%E7%B4%A2%E3%81%AF%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%81%A7%E3%82%84%E3%82%8D%E3%81%86 翻訳: WebAPI 設計のベストプラクティス

* Migrationの使い方

* チュートリアル

* API First

API Firstで開発しよう。

.link https://developer.ntt.com/ja/blog/58aa2ca4-ef7c-4f50-86b6-b5758df58de6 APIファーストで開発するメリットとは？

1. treasure-app-2021/swagger/swagger.yamlを編集する
2. treasure-app-2021/backend/で make genする
3. endpoint生やす
4. ロジックを作る

* Swaggerを編集しよう

.link https://stoplight.io/studio/ Stoplight Studio

Models -> New Model -> HelloWorld で適当なモデルを作る
Paths -> New Path -> GET /helloworld でエンドポイント作成。
GET /helloworldの200のResponseに先程作ったHelloWorldモデルを使う。

* 作成例

.image ./assets/endpoint.png 558 602

* コードジェネレート

  ❯ cd backend && make gen
  ❯ git status

ファイルが新しく生成されているので、コードを見てみよう。

* HelloWorld Model

    // Code generated by go-swagger; DO NOT EDIT.

    package generated_swagger

    // This file was generated by the swagger tool.
    // Editing this file might prove futile when you re-run the swagger generate command

    import (
        "context"

        "github.com/go-openapi/strfmt"
        "github.com/go-openapi/swag"
    )

    // HelloWorld Hello
    //
    // swagger:model HelloWorld
    type HelloWorld struct {

        // message
        Message string `json:"message,omitempty"`
    }
    ...

* http request

    ❯ curl -v localhost:1991/helloworld
    *   Trying ::1...
    * TCP_NODELAY set
    * Connected to localhost (::1) port 1991 (#0)
    > GET /helloworld HTTP/1.1
    > Host: localhost:1991
    > User-Agent: curl/7.64.1
    > Accept: */*
    >
    < HTTP/1.1 200 OK
    < Date: Thu, 20 May 2021 07:42:27 GMT
    < Content-Length: 17
    < Content-Type: text/plain; charset=utf-8
    <
    * Connection #0 to host localhost left intact
    {"message":"Hey"}* Closing connection 0

/pingの実装を真似して、さくっとJSONレスポンスを返してみよう。

* 実装例

app/interfaces/api/server.go

    r.Methods(http.MethodGet).Path("/helloworld").
        HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        helloworld := generated_swagger.HelloWorld{
            Message: "Hey",
        }
        res, err := helloworld.MarshalBinary()
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        w.Header().Set("Content-Type", "application/json")
        w.Write(res)
    })

* 課題

* 記事詳細でユーザーの情報も返したい

要件

- GET /articles/{article_id} で記事詳細を取ってきた時に、作成者の情報も返したい。

* 私ならこう作る

* API

TODO

* 実装

TODO

* 記事へのコメント機能

作成された記事へのコメントをする機能を作ってみましょう。

要件

- 記事へコメントが出来る。
- 誰がコメントしたか分かる
- コメントはコメント作成者のみ削除できる。

* APIを考えよう

- エンドポイントのパスは？
- HTTPメソッドは何が望ましい？
- Request Body
- Response Body
- HTTP Status Code

* 作るもの

- model コメントの型定義
- repository コメントのインサート。
- usecase コメント投稿する。
- handler コメント投稿のhttpリクエストを受け取る。
- server.go　コメント投稿ハンドラとエンドポイントを紐付ける。
- SQL 記事へのコメント用のCREATE TABLE SQL
- etc...

* 私ならこう作る

* API

TODO

* 実装

TODO

* N+1問題を解決

記事投稿時のタグ付けが出来るが、このタグ付けのクエリは、N+1問題を抱えている。

要件

- N+1を解消してください。

* 私ならこう作る

* API

TODO

* 実装

TODO

* Beyond the twelve factor app

興味あれば、読んでみよう。きっと、今ならわかるはず。

.link https://tanzu.vmware.com/content/blog/beyond-the-twelve-factor-app Beyond the twelve factor app

* 追加課題

- N+1
- GraphQL